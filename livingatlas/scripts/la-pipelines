#!/usr/bin/env bash

CMD=$(basename $0)

# Where this is executing (to detect if we are in production)
SCRIPTPATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

FIND_DOCOPTS=$(which docopts)
FIND_YQ=$(which yq)

if [[ -z $FIND_DOCOPTS ]]
then
    echo "ERROR: Please install docopts https://github.com/docopt/docopts an copy it in your PATH"
    exit 1
fi

if [[ -z $FIND_YQ ]]
then
    echo "ERROR: Please install yq debian/ubuntu package (not the snap package), see https://github.com/mikefarah/yq"
    exit 1
fi

set -e # Stop on any failure

# Detect if we are in production or not
if [[ $SCRIPTPATH == "/usr/bin" ]] ; then PROD=true ; else PROD=false ; fi

if [[ $PROD = false ]]; then
  # the grep function doesnt work on Mac OSX - perl regex arent supported,
  # unless you install grep with `brew install grep`
  # see https://apple.stackexchange.com/questions/193288/how-to-install-and-use-gnu-grep-in-macos
  if [[ "$OSTYPE" == "darwin"*  ]]; then
    VER=$(ggrep -oPm1 "(?<=<version>)[^<]+" "../pom.xml")
  else
    VER=$(grep -om1 "(?<=<version>)[^<]+" "../pom.xml")
  fi
else
    VER=$(dpkg-query --show -f '${Version}' la-pipelines)
fi

WHEREL="[--local|--embedded|--cluster]"
WHERE="[--embedded|--cluster]"

eval "$(docopts -V - -h - : "$@" <<EOF

LA-Pipelines data ingress utility.

The $CMD can be executed to run all the ingress steps or only a few of them:

Pipeline ingress steps:

    ┌───── do-all ──────────────────────────────────┐
    │                                               │
dwca-avro --> interpret --> uuid -->                │
     export-latlng --> sample --> sample-avro --> index

-  'dwca-avro' reads a Dwc-A and converts it to an Avro file;
-  'interpret' reads a Dwc-A, interprets it and write the interpreted data and the issues in Avro files;
-  'uuid' minting on new records and rematching existing UUIDs to records that have been previously loaded;
-  'export-latlng' exports a unique set of coordinates for a dataset into CSV;
-  'sample' crawl the LA layers. Requires an input csv containing lat, lng (no header) and output directory.
-  'sample-avro' adds a sampling AVRO extension to the stored interpretation
-  'index' reads a Dwc-A, interprets it and index the interpeted data creating a SOLR index.

All the steps generate an output. If only the final output is desired, the intermediate outputs can be ignored.

Usage:
  $CMD [options] dwca-avro     (<dr>...|all)
  $CMD [options] interpret     (<dr>...|all) $WHEREL
  $CMD [options] uuid          (<dr>...|all)         $WHERE
  $CMD [options] export-latlng (<dr>...|all)         $WHERE
  $CMD [options] sample        (<dr>...|all)
  $CMD [options] sample-avro   (<dr>...|all)         $WHERE
  $CMD [options] index         (<dr>...|all) $WHEREL
  $CMD [options] do-all        (<dr>...|all) $WHEREL
  $CMD -h | --help
  $CMD -v | --version

Options:
  --config=<files>     Comma separated list of alternative la-pipeline yaml configurations (the last file has the highest precedence).
  --extra-args=<args>  Additional "arg1=values,arg2=value" to pass to pipeline options (highest precedence than yml values).
  --no-colors          No colorize logs output.
  --dry-run            Print the commands without actually running them.
  --debug              Debug $CMD.
  -h --help            Show this help.
  -v --version         Show version.
----
$CMD $VER
License Apache-2.0
EOF
)"

# Enable logging
if ($debug) ; then verbosity=6; else verbosity=5; fi
if [[ $PROD = true ]] ; then LIB_DIR=/usr/share/la-pipelines ; else LIB_DIR=. ; fi
source $LIB_DIR/logging_lib.sh $verbosity $no_colors $dr

STEP=Initial

trap ctrlc_catch SIGINT
ctrlc_catch() {
    log.warn "$CMD canceled in $STEP step"
    # Cancel error catch
    trap - EXIT
}

# Error trap based in
# https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700
trap 'error_catch $? $LINENO' EXIT
error_catch() {
    log.error "Unexpected error during $STEP step"
    if [ "$1" != "0" ]; then
        log.error "Error $1 occurred on $2"
    fi
}

log.info "Starting $CMD"
log.debug "Production: $PROD"

if [[ $PROD = true ]] ; then CONFIG_DIR=/data/la-pipelines/config ; else CONFIG_DIR=../configs; fi

if ($dry_run); then _D=echo; else _D=; fi
# Set default config locations for Production and Development
if [[ -z $config ]]; then config=$CONFIG_DIR/la-pipelines.yaml,$CONFIG_DIR/la-pipelines-local.yaml; fi

if [[ $PROD = false && $no_colors = false ]]; then logConfig=$PWD/../pipelines/src/main/resources/log4j-colorized.properties; fi
if [[ $PROD = false && $no_colors = true ]];  then logConfig=$PWD/../pipelines/src/main/resources/log4j.properties; fi
if [[ $PROD = true &&  $no_colors = false ]]; then logConfig=$CONFIG_DIR/log4j-colorized.properties; fi
if [[ $PROD = true &&  $no_colors = true ]];  then logConfig=$CONFIG_DIR/log4j.properties; fi

for dr in "${dr[@]}"; do
    if [[ -n $dr && $dr != all && $dr != dr* ]]; then >&2 log.error "Wrong dataResource '$dr'. It should start with 'dr', like 'dr893'"; exit 1 ; fi
done

if [[ -n $extra_args ]] ; then
    # Convert arg1=val1,arg2=val2 into --arg1=val1 --arg2=val2
    ARGS=${extra_args//,/ \-\-}
    ARGS=--${ARGS}
else
    ARGS=
fi

log.info Config: $config
log.info Extra arguments: $ARGS
log.debug Logs without colors: $no_colors
log.debug log4j config: $logConfig

# Convert config to a list of files space separated
configList=${config//,/ }
log.debug Config list: $configList

for f in $configList $logConfig
do
    if [[ ! -f $f ]] ; then log.error File $f doesn\'t exits ; exit 1; fi
done

# Validate yaml of configs
for f in $configList
do
    YML_V=$(yq v $f; echo $?)
    if [[ $YML_V != 0 ]] ; then log.error Config $f is not valid ; exit 1; fi
done

# Gets a config value from yaml configList files
function getConf() {
    val=
    for i in $configList
    do
        valTmp=$(yq r $i $1)
        if [[ -n $valTmp ]] ; then val=$valTmp; fi
    done
    echo $val
}

function toArg() {
  PREFIX=$1
  KEY=$2
  echo --$KEY $(getConf $PREFIX.$KEY)
}

## Process run options

# Where to run, --local/etc options has precedence over yaml run.platform
if ($local || $dwca_avro || $sample)  ; then TYPE=local;
elif ($embedded) ; then TYPE=spark-embedded;
elif ($cluster) ; then TYPE=spark-cluster;
else TYPE=$(getConf run.platform);
fi

if [[ $TYPE = "spark-cluster" ]]; then USE_CLUSTER=true; else USE_CLUSTER=false; fi

log.info "Running in: $TYPE"
log.debug "Is cluster: $USE_CLUSTER"

if [[ $PROD = true ]]; then PIPELINES_JAR=$LIB_DIR/la-pipelines.jar
else
    PIPELINES_JAR=../pipelines/target/pipelines-$VER-shaded.jar
fi

# dwca-avro, sample and dump-datasize uses local_jar
LOCAL_PIPELINES_JAR=$PIPELINES_JAR

if [[ $USE_CLUSTER = true ]]; then PIPELINES_JAR=$(getConf run.spark-cluster.jar); fi

for JAR in $LOCAL_PIPELINES_JAR; do
    if [[ ! -f $JAR ]]
    then
        log.error "Cannot find $JAR."
        exit 1
    fi
done

FS_PATH=$(getConf fs.$(getConf fs.platform).fsPath)
if [[ ! -d $FS_PATH ]]
then
    log.error "Cannot find $FS_PATH."
    exit 1
fi

SPARK_TMP=$(getConf run.$TYPE.sparkTmp)

SPARK_MASTER=$(getConf run.$TYPE.sparkMaster)

DWCA_IMPORT=$(getConf run.$TYPE.dwcaImportDir)

DWCA_TMP=$(getConf run.$TYPE.dwcaTmp)

log.debug Target $(getConf general.targetPath)
log.debug Jar: $PIPELINES_JAR
log.debug Spark tmp: $SPARK_TMP

FS_PATH_ARG="--fsPath=$FS_PATH"

ARGS="$ARGS $FS_PATH_ARG"

# Uncomment this to debug log4j
# if ( $debug) ; then EXTRA_JVM_CLI_ARGS="-Dlog4j.debug"; fi

# Set log4j configuration for v1 and v2
EXTRA_JVM_CLI_ARGS="$EXTRA_JVM_CLI_ARGS -Dlog4j.configuration=file://$logConfig -Dlog4j.configurationFile=file://$logConfig"
log.debug EXTRA_JVM_CLI_ARGS: $EXTRA_JVM_CLI_ARGS

function logStepStart() {
    name=$1
    dr=$2
    STEP="$1 $2"
    log.info $(date)
    log.info "START ${colpur}$name${colrst} of $dr"
}

function logStepEnd() {
    name=$1
    dr=$2
    type=$3
    duration=$4
    log.info $(date)
    log.info "END ${colpur}$name${colrst} of $dr in [$type], took $(($duration / 60)) minutes and $(($duration % 60)) seconds."
}

function dwca-avro () {
    dr=$1

    if [[ $dr != "all" ]] ; then

      SECONDS=0
      logStepStart "DWCA-AVRO conversion" $dr

      dwca_dir="$DWCA_IMPORT/$dr/$dr.zip"

      export TMPDIR=$DWCA_TMP

      $_D java $EXTRA_JVM_CLI_ARGS -Dspark.local.dir=$SPARK_TMP \
          -cp $LOCAL_PIPELINES_JAR au.org.ala.pipelines.beam.ALADwcaToVerbatimPipeline \
          --datasetId=$dr \
          --config=$config $ARGS

      logStepEnd "DWCA-AVRO conversion" $dr local $SECONDS

    else
      SECONDS=0
      logStepStart "DWCA-AVRO conversion" $dr

      dwca_dir="$DWCA_IMPORT"

      export TMPDIR=$DWCA_TMP

      $_D java $EXTRA_JVM_CLI_ARGS -Dspark.local.dir=$SPARK_TMP \
          -cp $LOCAL_PIPELINES_JAR au.org.ala.pipelines.beam.ALADwcaToVerbatimPipeline \
          --datasetId=$dr \
          --inputPath=$dwca_dir \
          --config=$config $ARGS

      logStepEnd "DWCA-AVRO conversion" $dr local $SECONDS
    fi
}

function interpret () {
    dr=$1
    ltype=$2
    CLASS=au.org.ala.pipelines.beam.ALAVerbatimToInterpretedPipeline

    SECONDS=0
    logStepStart "Interpretation" $dr

    PRE=interpret-sh-args.local
    if [[ $ltype = "local" ]] ; then
        CLASS=au.org.ala.pipelines.java.ALAVerbatimToInterpretedPipeline
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm) \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr \
            --config=$config $ARGS
    fi

    PRE=interpret-sh-args.spark-embedded
    if [[ $ltype = "spark-embedded" ]] ; then
        log.info $(date)
        SECONDS=0
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm) \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr \
            --config=$config $ARGS
    fi

    PRE=interpret-sh-args.spark-cluster
    if [[ $ltype = "spark-cluster" ]] ; then
        $_D /data/spark/bin/spark-submit \
            --name "interpret $dr" \
            $(toArg $PRE conf) \
            $(toArg $PRE num-executors) \
            $(toArg $PRE executor-cores) \
            $(toArg $PRE executor-memory) \
            $(toArg $PRE driver-memory) \
            --class $CLASS \
            --master $SPARK_MASTER \
            --driver-java-options "-Dlog4j.configuration=file:$CONFIG_DIR/log4j.properties" \
            $PIPELINES_JAR \
            --datasetId=$dr \
            --config=$config $ARGS
            # TODO set here an optional colorized log4j properties
    fi

    logStepEnd "Interpretation" $dr $ltype $SECONDS
}

function uuid () {
    dr=$1
    ltype=$2
    CLASS=au.org.ala.pipelines.beam.ALAUUIDMintingPipeline

    logStepStart "UUID pipeline" $dr
    SECONDS=0

    PRE=uuid-sh-args.spark-embedded
    if [[ $ltype = "spark-embedded" || $ltype = "local" ]] ; then
        # TODO: we can put this in a function? Same code that interpret
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm)  \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr\
            --config=$config $ARGS
    fi

    PRE=uuid-sh-args.spark-cluster
    if [[ $ltype = "spark-cluster" ]] ; then
        $_D /data/spark/bin/spark-submit \
            --name "uuid-minting $dr" \
            $(toArg $PRE num-executors) \
            $(toArg $PRE executor-cores) \
            $(toArg $PRE executor-memory) \
            $(toArg $PRE driver-memory) \
            --class $CLASS \
            --master $SPARK_MASTER \
            --driver-java-options "-Dlog4j.configuration=file:$CONFIG_DIR/log4j.properties" \
            $PIPELINES_JAR \
            --datasetId=$dr \
            --config=$config $ARGS
            # TODO set here an optional colorized log4j properties
    fi

    logStepEnd "UUID" $dr $ltype $SECONDS
}

function export-latlng () {
    dr=$1
    ltype=$2
    CLASS=au.org.ala.pipelines.beam.ALAInterpretedToLatLongCSVPipeline

    logStepStart "Export latlng" $dr
    SECONDS=0

    PRE=export-latlng-sh-args.spark-embedded
    if [[ $ltype = "spark-embedded" || $ltype = "local" ]] ; then
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm)  \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr \
            --config=$config $ARGS
    fi

    PRE=export-latlng-sh-args.spark-cluster
    if [[ $ltype = "spark-cluster" ]] ; then
        $_D /data/spark/bin/spark-submit \
            --name "Export $dr" \
            $(toArg $PRE num-executors) \
            $(toArg $PRE executor-cores) \
            $(toArg $PRE executor-memory) \
            $(toArg $PRE driver-memory) \
            --class $CLASS \
            --master $SPARK_MASTER \
            --driver-java-options "-Dlog4j.configuration=file:$CONFIG_DIR/log4j.properties" \
            $PIPELINES_JAR \
            --datasetId=$dr \
            --config=$config $ARGS
            # TODO set here an optional colorized log4j properties
    fi

    logStepEnd "Export latlng" $dr $ltype $SECONDS
}

function sample () {
    dr=$1
    CLASS=au.org.ala.sampling.LayerCrawler

    logStepStart "Sampling" $dr
    SECONDS=0

    PRE=sample-sh-args.local
    $_D java $EXTRA_JVM_CLI_ARGS \
        $(getConf $PRE.jvm)  \
        -cp $LOCAL_PIPELINES_JAR $CLASS \
        --datasetId=$dr \
        --config=$config $ARGS

    logStepEnd "Sampling" $dr local $SECONDS
}

function sample-avro () {
    dr=$1
    ltype=$2
    CLASS=au.org.ala.pipelines.beam.ALASamplingToAvroPipeline

    logStepStart "Sample-avro" $dr
    SECONDS=0

    PRE=sample-avro-sh-args.spark-embedded
    if [[ $ltype = "spark-embedded" || $ltype = "local" ]] ; then
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm)  \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr \
            --config=$config $ARGS
    fi

    PRE=sample-avro-sh-args.spark-cluster
    if [[ $ltype = "spark-cluster" ]] ; then
        $_D /data/spark/bin/spark-submit \
            --name "add-sampling $dr" \
            $(toArg $PRE conf) \
            $(toArg $PRE num-executors) \
            $(toArg $PRE executor-cores) \
            $(toArg $PRE executor-memory) \
            $(toArg $PRE driver-memory) \
            --class $CLASS \
            --master $SPARK_MASTER \
            --driver-java-options "-Dlog4j.configuration=file:$CONFIG_DIR/log4j.properties" \
            $PIPELINES_JAR \
            --datasetId=$dr \
            --config=$config $ARGS
            # TODO set here an optional colorized log4j properties
    fi

    logStepEnd "Sample-avro" $dr $ltype $SECONDS
}

function index () {
    dr=$1
    ltype=$2
    CLASS=au.org.ala.pipelines.java.ALAInterpretedToSolrIndexPipeline

    logStepStart "Indexing" $dr
    SECONDS=0

    PRE=index-sh-args.local
    if [[ $ltype = "local" ]] ; then
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm)  \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr \
            --config=$config $ARGS
    fi

    PRE=index-sh-args.spark-embedded
    if [[ $ltype = "spark-embedded" ]] ; then
        CLASS=au.org.ala.pipelines.beam.ALAInterpretedToSolrIndexPipeline
        $_D java $EXTRA_JVM_CLI_ARGS \
            $(getConf $PRE.jvm)  \
            -cp $PIPELINES_JAR $CLASS \
            --datasetId=$dr \
            --config=$config $ARGS
    fi

    PRE=index-sh-args.spark-cluster
    if [[ $ltype = "spark-cluster" ]] ; then
        CLASS=au.org.ala.pipelines.beam.ALAInterpretedToSolrIndexPipeline
        $_D /data/spark/bin/spark-submit \
            --name "SOLR indexing for $dr" \
            $(toArg $PRE conf) \
            $(toArg $PRE num-executors) \
            $(toArg $PRE executor-cores) \
            $(toArg $PRE executor-memory) \
            $(toArg $PRE driver-memory) \
            --class $CLASS  \
            --master $SPARK_MASTER \
            --driver-java-options "-Dlog4j.configuration=file:$CONFIG_DIR/log4j.properties" \
            $PIPELINES_JAR \
            --datasetId=$dr \
            --config=$config $ARGS
            # TODO set here an optional colorized log4j properties
    fi

    logStepEnd "Indexing" $dr $ltype $SECONDS
}

if [[ $dr = "all" ]] ; then
    log.info Dump dataset size for all
    java $EXTRA_JVM_CLI_ARGS -cp $LOCAL_PIPELINES_JAR au.org.ala.utils.DumpDatasetSize \
         --config=$config $ARGS
fi # This should create /tmp/dataset-counts.csv

if ($do_all || $dwca_avro) ; then
    if [[ $dr != "all" ]] ; then
        for dr in "${dr[@]}"; do
            dwca-avro $dr
        done
    else
        dwca-avro "all"
    fi
fi

if ($interpret || $do_all); then
    if [[ $dr != "all" ]] ; then
        for dr in "${dr[@]}"; do
            interpret $dr $TYPE
        done
    else
        while IFS=, read -r datasetID recordCount
        do
            log.info "Dataset = $datasetID and count = $recordCount"
            if [ "$recordCount" -gt "50000" ]; then
                if [ $USE_CLUSTER = true ]; then
                    interpret $datasetID spark-cluster
                else
                    interpret $datasetID spark-embedded
                fi
            else
                interpret $datasetID local
            fi
        done < /tmp/dataset-counts.csv
    fi
fi

if ($uuid || $do_all); then
    if [[ $dr != "all" ]] ; then
        for dr in "${dr[@]}"; do
            uuid $dr $TYPE
        done
    else
        while IFS=, read -r datasetID recordCount
        do
            log.info "Dataset = $datasetID and count = $recordCount"
            if [ "$recordCount" -gt "50000" ]; then
                if [ $USE_CLUSTER = true ]; then
                    uuid $datasetID spark-cluster
                else
                    uuid $datasetID spark-embedded
                fi
            else
                uuid $datasetID spark-embedded
            fi
        done < /tmp/dataset-counts.csv
    fi
fi

if ($export_latlng || $do_all); then
  if [[ $dr != "all" ]] ; then
      for dr in "${dr[@]}"; do
          export-latlng $dr $TYPE
      done
  else
      while IFS=, read -r datasetID recordCount
      do
          log.info "Dataset = $datasetID and count = $recordCount"
          if [ "$recordCount" -gt "50000" ]; then
              if [ $USE_CLUSTER = true ]; then
                  export-latlng $datasetID spark-cluster
              else
                  export-latlng $datasetID spark-embedded
              fi
          else
              export-latlng $datasetID spark-embedded
          fi
      done < /tmp/dataset-counts.csv
  fi
fi

if ($sample || $do_all); then
    if [[ $dr != "all" ]] ; then
        sample $dr
    else
        while IFS=, read -r datasetID recordCount
        do
            sample $datasetID
        done < /tmp/dataset-counts.csv
    fi
fi

if ($sample_avro || $do_all); then
    if [[ $dr != "all" ]] ; then
        for dr in "${dr[@]}"; do
            sample-avro $dr $TYPE
        done
    else
        while IFS=, read -r datasetID recordCount
        do
            log.info "Dataset = $datasetID and count = $recordCount"
            if [ "$recordCount" -gt "50000" ]; then
                if [ $USE_CLUSTER = true ]; then
                    sample-avro $datasetID spark-cluster
                else
                    sample-avro $datasetID spark-embedded
            fi
        else
            sample-avro $datasetID spark-embedded
        fi
        done < /tmp/dataset-counts.csv
    fi
fi

if ($index || $do_all); then
    if [[ $dr != "all" ]] ; then
        for dr in "${dr[@]}"; do
            index $dr $TYPE
        done
    else
        while IFS=, read -r datasetID recordCount
        do
            log.info "Dataset = $datasetID and count = $recordCount"
            if [ "$recordCount" -gt "50000" ]; then
                if [ $USE_CLUSTER = true ]; then
                    index $datasetID spark-cluster
                else
                    index $datasetID spark-embedded
                fi
            else
                index $datasetID java
            fi
        done < /tmp/dataset-counts.csv
    fi
fi

# All ended correctly, so untrap EXIT catch
trap - EXIT
